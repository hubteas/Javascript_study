day62
defer, async -> 쓰레드 -> 동기와 비동기 

★ 8/23/금 휴강 => 8/30/금 보강

1. defer, async
   웹 브라우저에서 돌아가는 스크립트는 대부분 HTML보다 무겁다
   용량이 커서 다운로드 받을 때도 오랜 시간이 걸리고 처리할 때도 오래 걸린다

   브라우저는 HTML을 읽다가 <script></script> 태그를 만나면 스크립트를 먼저 실행해야 하므로
   DOM 생성을 멈춘다
   src 속성이 있는 외부 스크립트가 적용되어도 동일하다(외부에서 스크립트를 다운받고 실행한 후에 남은
   페이지를 처리할 수 있다)

- 스크립트에서는 스크립트 아래에 있는 DOM요소에 접근할 수 없다
   DOM요소에 이벤트핸들러를 추가하는 등의 사용이 불가능하다
- 페이지 위쪽에 용량 큰 스크립트가 있는 경우 스크립트가 페이지를 막아버린다
   페이지에 접속하는 사용자들은 스크립트를 다운받고 실행할 때 스크립트 아래쪽에 있는 페이지를 볼 수 없다

1) defer
   defer 속성이 있는 스크립트를 백그라운드에서 다운로드 한다
   지연스크립트를 다운로드 하는 도중에도 HTML 파싱이 멈추지 않고 defer 스크립트 실행은
   페이지 구성을 끝날 때까지 지연된다

- 지연 스크립트는 페이지 생성을 절대 막지 않는다
- 지연 스크립트는 DOM에 준비된 후에 실행되긴 하지만 DOMContentLoaded 이벤트 발생전에 실행된다
※ defer 속성은 외부 스크립트에만 유효하다
   <script defer src=""></script>
   src 속성이 없으면 무시된다

2) async(비동기 스크립트)
   페이지와 완전히 독립적으로 동작한다

- 백그라운드에서 다운로드가 된다. HTML 페이지는 async 스크립트 다운이 완료되기를 기다리지 않고
   페이지 내 콘텐츠를 처리, 출력한다
   (async 스크립트 실행 중에는 HTML 파싱이 멈춘다)
- DOMContentLoaded 이벤트와 async 스크립트는 서로를 기다리지 않는다
   페이지 구성이 끝난 후에 async 스크립트 다운로딩이 끝난 경우 
   DOMContentLoaded는 async 스크립트 실행전에 발생할 수 있다

- async와 defer 스크립트는 다운로드 시 페이지 렌더링을 막지 않는다는 공통점이 있다

      순서         DOMContentLoaded
async      load-first order   비동기 스크립트는 HTML 문서가 완전히 다운로드 되지 않은 상태라도
      문서내 순서와 상관없이   로드 및 다운로드 할 수 있다
      먼저 다운로드 된 스크립트가
      먼저 실행된다

defer      문서에 추가된 순      지연스크립트는 문서 다운로드와 파싱이 완료된 후에
               DOMContentLoaded 이벤트 발생전에 실행된다

2. 쓰레드
1) 동기화(synchronized)
   동기와 비동기의 흐름을 알기 위해서 쓰레드 개념을 먼저 알아야한다
   프로그램, 프로세스를 이해해야한다

2) 프로그램(program)
   실행되지 않은 상태
   사이트 접속 -> 다운로드 -> 설치 -> 아무것도 하지 않으면 실행x(더블클릭해야 실행)   

3) 프로세스(process)
   메모리에 올라가서 동작하는 실행된 프로그램

4) 쓰레드(thread)
   비동기식 방식으로 특정 연산을 수행할 때 업무를 효율적으로 처리하기 위해
   짧은 시간안에 다양한 연산들을 마치 동시에 처리하는 것처럼 할 수 있게 하는 것

- 단일 쓰레드
   처리경로를 한개만 가지고 있기 때문에 직렬적이다
   동시에 많은 양을 처리하기 힘들기 때문에 상대적으로 비효율적이다
   하지만 하나의 작업에 문제가 발생하더라도 다른 작업에는 영향을 끼치지 않는다
   따라서 안정성이 보장되고 설계시 멀티 쓰레드에 비해 쉽다
   장점 : 하나가 다 처리되지 않았을 때 다음이 실행되지 않아 안정성이 뛰어나다

- 멀티쓰레드
   하나의 프로세스를 동시에 처리하는 것처럼 보이지만 사실은 매우 짧은 단위로 분할해서 차례대로 처리한다
   여러개의 처리경로를 가질 수 있도록 하며, 동시작업도 가능해진다
   설계하기 굉장히 어렵고, 하나의 쓰레드가 문제 발생시 모든 쓰레드에 문제가 발생한다
   처리량 증가, 효율성 증가, 처리비용 감소의 장점이 있기 때문에 단점을 감수하고 설계한다
   (대표적으로 java언어가 해당된다)

5) 자바스크립트의 쓰레드
   자바스크립트 단일 쓰레드로, 한번에 하나의 작업만 수행할 수 있다
   자바스크립트는 이벤트 루프를 활용하여 테스트가 종료되지 않아도 곧바로 실행하는 함수를 처리하는 방식을 도입했다
   동기의 코드는 순차적인 흐름이지만 비동기는 처리시간이 각각 다르기 때문에 결과를 예상할 수 없다
   따라서 결과에 따라 비동기 이후 실행된 동기적함수를 실행시키기 위하여 비동기를 동기적으로 처리한다

3. 동기와 비동기★
1) 동기(Synchronous)
   요청을 보낸 후 다음 응답을 받아야만 다음 동작이 이루어지는 방식을 의미한다
   모든일은 순차적으로 실행되며 어떤 작업이 수행중이라면 다음 작업은 대기하게 된다

2) 비동기(Asynchronous)
   데이터를 수신하는 코드와 페이지를 표시하는 결과 비동기적으로 처리하는 방식을 의미한다
   들어오는 일은 모두 우선적으로 받아주고 끝났다는 이벤트가 전달되면 해당 이벤트를 처리한다
   자바스크립트에서는 기존에 콜백함수를 이용했지만 콜백 지옥에 빠질 가능성이 높기 때문에
   ES7이상에서는 promise를, ES8이상에서는 async와 await을 지원한다

3) 프로미스(promise)
   자바스크립트 비동기 처리에 사용되는 객체이다
   주로 서버에서 받아온 데이터를 화면에 표시할 때 사용한다

- 프로미스 상태 3가지
   대기(pending) : 비동기 작업이 아직 완료되지 않은 상태
   이행(fulfilled) : 비동기 작업이 성공적으로 완료된 상태
   거부(rejected) : 비동기 작업이 실패한 상태


4) async / await
   async 함수는 함수 선언 앞에 async 키워드를 붙여서 정의한다
   항상 프로미스를 반환한다
   async 함수 내에서 await 키워드를 사용하여 다른 프로미스나 기본값을 기다릴 수 있다

   await 함수는 async 함수내에서만 사용할 수 있다
   프로미스가 처리될 때까지 해당 함수의 실행이 일시중지된다
   프로미스가 이행되면 해당 값을 반환한다
   await 표현식은 프로미스를 반환하는 모든 비동기 작업에 사용될 수 있다

5) fetch
   자바스크립트에서 제공하는 비동기 네트워크 통신을 위한 기능이다
   HTTP 요청을 보내고 응답을 받아올 때 사용한다
   웹 어플리케이션에서 서버와 데이터를 주고받을 때 많이 사용된다

   fetch는 URL을 매개변수로 사용하여 요청을 보내고 프로미스를 반환한다
   네트워크 요청 : HTTP 요청 메소드(get, post, put, delete 등) 요청 헤더, 본문 등을 설정할 수 있다
   프로미스 기반 : .then(), .catch()를 사용하여 응답을 처리할 수 있다

7. json 무료 가상 REST API서버 : JSONPlaceholder
   테스트 및 프로토 타이핑을 위한 무료 가상 API를 제공하는 사이트
   6가지의 데이터 API 주소를 호출하여 데이터를 JSON으로 받아 볼 수 있다

   https://jsonplaceholder.typicode.com/

   /posts   100 posts
   /comments   500 comments
   /albums   100 albums
   /photos   5000 photos
   /todos   200 todos
   /users   10 users